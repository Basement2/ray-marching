{
  "version": 3,
  "sources": ["../src/ray-marching.ts"],
  "sourcesContent": ["export class RayMarching extends HTMLElement {\n  $canvas: HTMLCanvasElement;\n  gl: WebGLRenderingContext;\n  program: WebGLProgram;\n  attribLocation: number;\n  uniformLocation: {\n    resolution: WebGLUniformLocation;\n    mouse: WebGLUniformLocation;\n    time: WebGLUniformLocation;\n  };\n  requestID: number;\n  time: number;\n  beginAt: number;\n  resizeObserver: ResizeObserver;\n  intersectionObserver: IntersectionObserver;\n  isIntersecting: boolean;\n\n  constructor() {\n    super();\n    this.attachShadow({ mode: \"open\" });\n    this.isIntersecting = false;\n    this.shadowRoot.innerHTML = this.template();\n    // Element\n    this.$canvas = this.shadowRoot.querySelector(\"canvas\");\n    // Context\n    this.gl = this.$canvas.getContext(`webgl`);\n    if (this.gl === null) {\n      throw new Error(\"WebGL not supported.\");\n    }\n  }\n\n  attributeChangedCallback() {}\n\n  connectedCallback() {\n    setTimeout(() => {\n      this.setupShader();\n\n      // Event\n      this.resizeObserver = new ResizeObserver(this.handleResize.bind(this));\n      this.resizeObserver.observe(this);\n      this.intersectionObserver = new IntersectionObserver(\n        this.handleIntersection.bind(this),\n        {\n          root: null,\n        }\n      );\n      this.intersectionObserver.observe(this);\n\n      this.addEventListener(\"mousemove\", this.handleMousemove.bind(this));\n\n      this.beginAt = Date.now();\n\n      console.warn(44444);\n\n      // this.render();\n    }, 0);\n  }\n\n  disconnectedCallback() {\n    cancelAnimationFrame(this.requestID);\n    this.resizeObserver.unobserve(this);\n    this.intersectionObserver.unobserve(this);\n  }\n\n  handleResize(entries) {\n    const { width, height } = entries[0].contentRect;\n    this.$canvas.width = width / 2;\n    this.$canvas.height = height / 2;\n    this.gl.uniform2fv(this.uniformLocation.resolution, [\n      this.$canvas.width,\n      this.$canvas.height,\n    ]);\n  }\n\n  handleIntersection(entries) {\n    const isIntersecting = entries[0].isIntersecting;\n    if (this.isIntersecting && !isIntersecting) {\n      cancelAnimationFrame(this.requestID);\n    }\n    if (!this.isIntersecting && isIntersecting) {\n      this.render();\n    }\n    this.isIntersecting = isIntersecting;\n  }\n\n  handleMousemove(e) {\n    this.gl.uniform2fv(this.uniformLocation.mouse, [\n      Math.max(0, e.offsetX) / this.clientWidth,\n      (this.clientHeight - e.offsetY) / this.clientHeight,\n    ]);\n  }\n\n  setupShader() {\n    const fShaderScript = this.querySelector('[type=\"x-shader/x-fragment\"]');\n    const vs = this.createShader(\n      this.gl.VERTEX_SHADER,\n      `attribute vec3 position;void main(){gl_Position=vec4(position,1.);}`\n    );\n    const fs = this.createShader(\n      this.gl.FRAGMENT_SHADER,\n      fShaderScript.textContent\n    );\n    this.program = this.createProgramObject(vs, fs);\n    this.gl.useProgram(this.program);\n\n    // Get location\n    this.attribLocation = this.gl.getAttribLocation(this.program, \"position\");\n    this.uniformLocation = {\n      resolution: this.gl.getUniformLocation(this.program, \"resolution\"),\n      mouse: this.gl.getUniformLocation(this.program, \"mouse\"),\n      time: this.gl.getUniformLocation(this.program, \"time\"),\n    };\n\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.gl.createBuffer());\n    this.gl.bufferData(\n      this.gl.ARRAY_BUFFER,\n      new Float32Array([-1, 1, 0, -1, -1, 0, 1, 1, 0, 1, -1, 0]),\n      this.gl.STATIC_DRAW\n    );\n    this.gl.enableVertexAttribArray(this.attribLocation);\n    this.gl.vertexAttribPointer(\n      this.attribLocation,\n      3,\n      this.gl.FLOAT,\n      false,\n      0,\n      0\n    );\n  }\n\n  template() {\n    return `\n      <style>\n        :host {\n          display: block;\n          width: 100%;\n          height: 100%;\n        }\n        .container {\n        }\n        canvas {\n          width: 100%;\n          height: 100%;\n        }\n      </style>\n      <div class=\"container\">\n        <slot></slot>\n        <canvas></canvas>\n      </div>\n    `;\n  }\n\n  createShader(type, source): WebGLShader | string {\n    const shader = this.gl.createShader(type);\n    this.gl.shaderSource(shader, source);\n    this.gl.compileShader(shader);\n    if (this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n      return shader;\n    }\n    return this.gl.getShaderInfoLog(shader);\n  }\n\n  createProgramObject(vs, fs): WebGLProgram | string {\n    const program = this.gl.createProgram();\n    this.gl.attachShader(program, vs);\n    this.gl.attachShader(program, fs);\n    this.gl.linkProgram(program);\n    this.gl.deleteShader(vs);\n    this.gl.deleteShader(fs);\n    if (this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {\n      this.gl.useProgram(program);\n      return program;\n    }\n    return this.gl.getProgramInfoLog(program);\n  }\n\n  render() {\n    // Clear\n    this.gl.viewport(0, 0, this.$canvas.width, this.$canvas.height);\n    this.gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n\n    // Sec.\n    this.gl.uniform1f(\n      this.uniformLocation.time,\n      (Date.now() - this.beginAt) * 0.001\n    );\n\n    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n    this.requestID = requestAnimationFrame(this.render.bind(this));\n  }\n}\n\nwindow.customElements.define(\"ray-marching\", RayMarching);\n"],
  "mappings": "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",
  "names": []
}
